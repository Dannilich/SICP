;Решения задач из SICP, в дополнение задач из курса основам компьютерных наук
#lang racket


;№1.4
;Ответ: в зависимости от знака b, вычисления идут с + или -

;№1.5
;Ответ: в нормативном не будет ошибки, в апликативном будет, т.к. будет ош. вычисления функции p

;№1.6
;В силу аппликативного подхода вычислений cond, будут вычислять все альтернативы, даже если они не нужны.
;if - ленивый, поэтому он избегает лишних вычислений. Поэтому, этим способом невозможно корректно воосоздать if

;№1.7
;см. Building functional abstractions.rkt

;№1.9
;1-ый: накапливает продолжения, как долг потом добавить - рекурсивыный процесс
;2-ой: перетаскивая по единице, аккумулирует в передаваемом занчении рез-т, который потом выводит - итеративный процесс

;№1.10
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
;f = 2*n
;g = 2^n
;h = 2 (^2  n-раз)

;№1.12
(define (binomial-coeficent n m)
  (if (or (= n m) (= n 0) (= m 0))
      1
      (if (or (< n 0) (< m 0) (> m n))
          0
          (+ (binomial-coeficent (- n 1) m) (binomial-coeficent (- n 1) (- m 1))))))

;№1.14
;Нарисовал, но только не прикрепить)

;№1.15
;а) P вызовется 5 раз
;б) Время и память: О(logn) или точнее Тета([(lnx + ln10)/ ln3] с округлением вверх)

;№1.16, 1.17, 1.18
;см. Egyptian multiplication.rkt

;No1.20
(define (gcd a b)
  (if (zero? b)
      a
      (gcd b (remainder a b))))
;Апликативный порядок: 4раза
;Нормальный порядок: 18 раз =  14 раз в условиях будут вычислятся, через накопленные вызовы + 4 раза итоговое вычисление ответа (перем а)

;№1.31, 1.32, 1.33
;см. Building functional abstractions.rkt

;№1.34
;(f f) сведётся к аппликации (2 2) --> ошибка

;№2.4
;Это просто представление через лямбда-исчисление

;№2.5
;Да, можно. За счет того что основания взаимнопростые, можно пошагово делить до отсутствия делимости числа пары. Кол-во произведенных делений по основанию xi - представление i-ого элемента.

;№2.6
;Прямое представление нумеравлов черча, как n-кратное применение функции к переменной 2: (f (f x)) или (x (x y)

;No2.55
;Выводится quote, поскольку кавычка 'x - синтаксический сахар от (quote x)


;Слишком простые: 1.1-1.3, 1.8, 1.11(перестановка, сдвиг аргументов), 1.19, 1.30