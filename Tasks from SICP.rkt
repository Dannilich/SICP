;Решения задач из SICP, в дополнение задач из курса основам компьютерных наук
#lang racket


;Глава 1:

;№1.4
;Ответ: в зависимости от знака b, вычисления идут с + или -

;№1.5
;Ответ: в нормативном не будет ошибки, в апликативном будет, т.к. будет ош. вычисления функции p

;№1.6
;В силу аппликативного подхода вычислений cond, будут вычислять все альтернативы, даже если они не нужны.
;if - ленивый, поэтому он избегает лишних вычислений. Поэтому, этим способом невозможно корректно воосоздать if

;№1.7
;см. Building functional abstractions.rkt

;№1.9
;1-ый: накапливает продолжения, как долг потом добавить - рекурсивыный процесс
;2-ой: перетаскивая по единице, аккумулирует в передаваемом занчении рез-т, который потом выводит - итеративный процесс

;№1.10
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
;f = 2*n
;g = 2^n

;№1.15
;а) P вызовется 5 раз
;б) Время и память: О(logn) или точнее Тета([(lnx + ln10)/ ln3] с округлением вверх)

;№1.31, 1.32, 1.33
;см. Building functional abstractions.rkt

;№1.34
;Новая функция будет обернута в себя, как еще одну аппликацию: ((g 2) 2)


;Слишком простые: 1.1-1.3, 1.8, 1.11(перестановка, сдвиг аргументов), 1.30



;Глава 2:

;№2.55
;Выводится quote, поскольку кавычка - синтаксический сахар этой команды 