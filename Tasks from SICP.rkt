;Решения задач из SICP, в дополнение задач из курса основам компьютерных наук
#lang racket


;Глава 1

;№1.3
(define (solution . nums  )
  (define squares (map (lambda (x) (* x x)) nums))
  (define sums (map (lambda (x y) (+ x y)) squares (append (cdr squares) (cons (car squares) '()))))
(foldl max 0 sums))

;№1.4
;Ответ: в зависимости от знака b, вычисления идут с + или -

;№1.5
;Ответ: в нормативном не будет ошибки, в апликативном будет, т.к. будет ош. вычисления функции p

;№1.6
;В силу аппликативного подхода вычислений cond, будут вычислять все альтернативы, даже если они не нужны.
;if - ленивый, поэтому он избегает лишних вычислений. Поэтому, этим способом невозможно корректно воосоздать if

;№1.7
;см. Building functional abstractions.rkt

;№1.9
;1-ый: накапливает продолжения, как долг потом добавить - рекурсивыный процесс
;2-ой: перетаскивая по единице, аккумулирует в передаваемом занчении рез-т, который потом выводит - итеративный процесс

;№1.10
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
;f = 2*n
;g = 2^n
;h = 2 (^2  n-раз)

;№1.12
(define (binomial-coeficent n m)
  (if (or (= n m) (= n 0) (= m 0))
      1
      (if (or (< n 0) (< m 0) (> m n))
          0
          (+ (binomial-coeficent (- n 1) m) (binomial-coeficent (- n 1) (- m 1))))))

;№1.14
;Нарисовал, но только не прикрепить)

;№1.15
;а) P вызовется 5 раз
;б) Время и память: О(logn) или точнее Тета([(lnx + ln10)/ ln3] с округлением вверх)

;№1.16, 1.17, 1.18
;см. Egyptian multiplication.rkt

;No1.20
(define (gcd a b)
  (if (zero? b)
      a
      (gcd b (remainder a b))))
;Апликативный порядок: 4раза
;Нормальный порядок: 18 раз =  14 раз в условиях будут вычислятся, через накопленные вызовы + 4 раза итоговое вычисление ответа (перем а)

;№1.31, 1.32, 1.33
;см. Building functional abstractions.rkt

;№1.34
;(f f) сведётся к аппликации (2 2) --> ошибка


;Глава 2

;№2.4
;Это просто представление через лямбда-исчисление
;(define (cdr z)
;  (z (lambda (p q) q)))

;№2.5
;Да, можно.
;За счет того что основания взаимнопростые, можно пошагово делить до отсутствия делимости числа пары. Кол-во произведенных делений по основанию xi - представление i-ого элемента.

;№2.6
;Прямое представление нумеравлов черча, как n-кратное применение функции к переменной 2: (f (f x)) или (x (x y))

;№2.17, 2.18
;см. Pairs and lists.rkt

;№2.21
(define (square-list items)
  (if (null? items)
      null
      (cons ((lambda (x) (* x x))(car items)) (square-list (cdr items)))))

(define (square-list2 items)
  (map (lambda (x) (* x x)) items))

;№2.22
;Не получилось, поотому что мы можем добавлять через cons только в конец списка, если действуем прямо.
;Перестановка аругументов не поможет, т.к. сделаем пару, в которой 1-ый элемент соберёт весь хвост

;№2.24
;Нарисовал то и то, но не прикрепить.
;Вложенный список (1 (2 3)) будет на стрелочной диаграмме изображаться как --> [ 1 | & ] --> [ & | \0 ] --> [ 2 | & ] --> [ 3 | \0 ]
;Где ячейка с & указывает на следующий элемент

;№2.25
;1) cddadr
;2) caar
;3) cdr 6 раз

;№2.26
;1) Расширит список 1 списком 2
;2) Создаст список, где 1-ым элементом будет 1 список, а последующим элементы 2 списка
;3) Создаст список списков 1 и 2

;№2.27, 2.28, 2.30, 2.31, 2.32
;см. Pairs and lists.rkt

;№2.33, 2.34, 2.35, 2.36 , 2.37, 2.38, 2.39
;см. Fold.rkt

;No2.55
;Выводится quote, поскольку кавычка 'x - синтаксический сахар от (quote x)


;Глава 3

;№3.1, 3.2, 3.3, 3.4, 3.7
;см. Side effect.rkt

;№3.8
(define (make-f)
  (let ((prod 1))
    (lambda (x)
      (set! prod (* prod x))
      prod)
 ))
;(define f (make-f))

; №3.12
; Просто выполнится побочный эффект, при котором х изменится,
;(cdr x):
;1) b
;2) b c d

;№3.13
; [ a | & ] -> [ b | & ] -> [ c | & ] -> [ a | & ] ->...
; last pair на нём войдет в бесконечный цикл, поскольку отсутствует null

;№3.14
;Разворот списка на месте,
;Т.к. в racket по умолчанию используется стратегия вычислений "вызов по значению", то изменения происходят в копии списка
;Т.е. исходный список не изменяется, но при этом возвращается измененный
(define (reverse! l)
  (define (loop i j)
    (if (null? i)
        j
        (let ([k (cdr i)])
          ;(set-cdr! i j) ;что-то ругается на это
          (loop k i))))
  (loop l null))
;Было:   v: [ 1 | & ] -> [ 2 | & ] -> [ 3 | \0] 
;Стало:  v: [ 1 | & ] -> [ 2 | & ] -> [ 3 | \0]   w: [ 3 | & ] -> [ 2 | & ] -> [ 1 | \0]

;№3.16
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
;3: (list 1 2 3)
;4: (cons (cons 1 varX) (cons varX 2))
;7: 
;Не завершится: зацикливание 1-> 2-> 3-> 1->...

;Глава 4


;Слишком простые: 1.1-1.2, 1.8, 1.11(перестановка, сдвиг аргументов), 1.19, 1.21, 1.30, 2.17, 2.20, 2.21, 2.23, 2.30 (2.31 еще абстрактнее), 3.15